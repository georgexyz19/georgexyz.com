<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous"> -->
    <link rel="stylesheet" href="/theme/css/bs4min.css">
    <link rel="shortcut icon" type="image/x-icon" href="https://www.georgexyz.com/theme/images/favicon.ico" >
    <link rel="icon" type="image/x-icon" href="https://www.georgexyz.com/theme/images/favicon.ico" >
 
    <link rel="stylesheet" href="https://www.georgexyz.com/theme/css/friendly.css">
    <link rel="stylesheet" href="https://www.georgexyz.com/theme/css/custom.css">
    <meta name="author" content="George Zhang" />
    <meta name="keywords" content="python,django" />
    <meta name="description" content="Django model fields are descriptors. The descriptor is a Python intermediate feature. It is almost impossible to understand FileField and ImageField source code without knowing Python descriptor. Marty Alchin’s …" />
    <title>Python Descriptor and Django Model Field - George Zhang</title>
  </head>
  <body>
    <!-- navbar -->
    <nav class="navbar navbar-expand-md navbar-light" style="background-color: #e3f2fd;">
      <div class="container">
        <a class="navbar-brand" href="/">George Zhang</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor01" aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarColor01">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item">
              <a class="nav-link " 
                href="/articlelist.html">Articles</a>
            </li>
            <li class="nav-item">
              <a class="nav-link pr-3 " 
                href="/tags.html">Tags</a>
            </li>
            <li class="nav-item">
              <a class="nav-link pr-3 "
                 href="/pages/inkscape-tutorial.html">Inkscape Tutorial</a>
            </li>
            <li class="nav-item">
                <a class="nav-link "
                   href="/pages/projects.html">Projects</a>
              </li>
          </ul>

          <ul class="navbar-nav">
            <li class="nav-item">
              <a class="nav-link " 
                 href="/pages/about.html">About</a>
            </li>
          </ul>
        </div>

      </div>
    </nav>

   
  
<div class="container">

  <div class="row">
    <div class="col-lg-8 mx-auto">   

  <h2>Python Descriptor and Django Model&nbsp;Field</h2>
  
  <div class="text-muted mb-2">
    <span>Posted on </span>
    <time datetime="2019-05-12 17:48:00-04:00">
      Sunday, 05/12/2019 17:48
    </time>
    
     <span>with tags: </span>
       <a href="https://www.georgexyz.com/tag/python.html">python</a>
/       <a href="https://www.georgexyz.com/tag/django.html">django</a>
  </div>
      
  <p>Django model fields are descriptors. The descriptor is a Python intermediate feature. 
It is almost impossible to understand FileField and ImageField source code 
without knowing Python descriptor.  Marty Alchin&#8217;s book <em>Pro Django</em> has 
a short section on descriptors (Page 31 to 33), but it lacks&nbsp;detail. </p>
<h3>Descriptor Online&nbsp;Articles</h3>
<p>After some google search, I found several articles on Python descriptors. 
The first article is Michael Driscoll&#8217;s 
<a href="https://www.blog.pythonlibrary.org/2016/06/10/python-201-what-are-descriptors/">Python 201: What are descriptors?</a>, 
which is a good introduction. The webpage has a link 
to Ned Batchelder&#8217;s blog site. I heard Ned Batchelder on 
<a href="https://talkpython.fm/">Talk Python To Me Podcase</a> and read his excellent 
<a href="https://nedbatchelder.com/text/unipain.html">article on Unicode</a> before. His blog post 
on descriptor is actually recommending a lightning talk and an article by Chris&nbsp;Beaumont. </p>
<p>Chris Beaumont&#8217;s article 
<a href="https://nbviewer.jupyter.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb">Python Descriptors Demystified</a> 
is possibly the best writing on descriptors.  Many descriptor techniques 
discussed in the article are directly used in Django Model source code. Here are the main points 
of the&nbsp;article:</p>
<ul>
<li>Descriptors are reusable&nbsp;properties</li>
<li>Put descriptors at class&nbsp;level</li>
<li>Keep instance level data instance&nbsp;specific</li>
<li>Label your&nbsp;descriptor</li>
<li>Label descriptors with&nbsp;Metaclasses</li>
</ul>
<p>The article itself is not very long, but the content takes time to understand. The article 
also beriefly discussed property. A short online article 
<a href="https://www.machinelearningplus.com/python/python-property/">Property Explained – How to Use and When</a> 
has nice Python property examples. The article also mentions meta classes.  Real 
Python website has 
<a href="https://realpython.com/python-metaclasses/">a nice introductory article on meta classes</a>. </p>
<p>Python official documentation has an article 
<a href="https://docs.python.org/3/howto/descriptor.html">Descriptor HowTo Guide</a> 
by Raymond Hettinger. This article is not easy and it takes time to&nbsp;digest. </p>
<p>Here is the 
<a href="https://github.com/georgexyz19/PythonDescriptor">link to my Github repo</a> 
which consists of code examples in those&nbsp;articles. </p>
<h3>Django Model&nbsp;Code</h3>
<p>This section is trying to answer the question &#8220;how does a class variable &#8216;name&#8217; 
become an instance variable&#8221;? The Django source code and line number reference below are from Django 
<a href="https://github.com/django/django/tree/2.1">version 2.1</a>. </p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="o">...</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span> <span class="o">=</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">bn</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">name</span>
</code></pre></div>


<p>The two lines of code below are from base.py ModelBase class (L138-139), which is
a metaclass for&nbsp;Model.</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">obj_name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">new_class</span><span class="o">.</span><span class="n">add_to_class</span><span class="p">(</span><span class="n">obj_name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
</code></pre></div>


<p>The attrs is the fourth argument to the <code>__new__</code> method in metaclass ModelBase. 
The obj_name refers to &#8216;name&#8217; and obj refers to <code>models.CharField(max_length=255)</code> 
where name is a field in Book model&nbsp;class. </p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</code></pre></div>


<p>The <code>add_to_class</code> method is defined on L301.  The method checks if the 
value being added has <code>contribute_to_class</code> method, and if it does it will call 
this method. Otherwise, the method calls <code>setattr</code> to set (name, value) pair 
as class attribute.  The <code>getattr</code> and <code>setattr</code> are python built-in&nbsp;functions. </p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add_to_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="c1"># We should call the contribute_to_class method only if it&#39;s bound</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;contribute_to_class&#39;</span><span class="p">):</span>
        <span class="n">value</span><span class="o">.</span><span class="n">contribute_to_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>  <span class="c1"># call this if Book has a field price = 50</span>
</code></pre></div>


<p>The <code>contribute_to_class</code> method is defined in <code>db/models/fields/__init__.py</code> L727. 
It is a method in Field class. 
This is where the actual magic happens.  The self, cls, and name in <code>contribute_to_class</code> 
are <code>models.CharField(max_length=255)</code>, <code>Book</code>, and <code>name</code>,&nbsp;respectively. </p>
<p>The first thing <code>contribute_to_class</code> does is it takes the value assigned to the 
class variable and stores it in class attribute _meta, which is an Options&nbsp;object. </p>
<p>The second thing it does is to assign an instance of a DeferredAttribute class 
to this field.  The class is a Descriptor in python. The construction of 
<code>DeferredAttribute</code> has an argument <code>self.attname</code>, which has the same name of 
the field.  It can be shown that for descriptor fields the <code>getattr(cls, self.attname, None)</code> 
function returns None.  The comments indicate that this line is intended for the class&nbsp;method. </p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">contribute_to_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">private_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Register the field with the model class it belongs to.</span>
<span class="sd">    If private_only is True, create a separate instance of this field</span>
<span class="sd">    for every subclass of cls, even if cls is not an abstract model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_attributes_from_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">if</span> <span class="n">private_only</span><span class="p">:</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">private</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">add_field</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">:</span>
        <span class="c1"># Don&#39;t override classmethods with the descriptor. This means that</span>
        <span class="c1"># if you have a classmethod and a field with the same name, then</span>
        <span class="c1"># such fields can&#39;t be deferred (we don&#39;t have a check for this).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attname</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>   <span class="c1"># attname is name</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">attname</span><span class="p">,</span> <span class="n">DeferredAttribute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attname</span><span class="p">))</span> 
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">choices</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;get_</span><span class="si">%s</span><span class="s1">_display&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">partialmethod</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_FIELD_display</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>
</code></pre></div>


<p>The <code>DeferredAttribute</code> descriptor class is defined in db.models.query_utils.py 
file L116.  The code for the class is not long, and they are shown below. 
The instance and cls in <code>__get__</code> method will be a book instance and cls will 
be Book class. The code in <code>__get__</code> method shows the subtle differences 
between <code>__dict__</code> attribute and <code>getattr</code> (search&nbsp;tree). </p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">DeferredAttribute</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper for a deferred-loading field. When the value is read from this</span>
<span class="sd">    object the first time, the query is executed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field_name</span> <span class="o">=</span> <span class="n">field_name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve and caches the value from the datastore on the first lookup.</span>
<span class="sd">        Return the cached value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Let&#39;s see if the field is part of the parent chain. If so we</span>
            <span class="c1"># might be able to reuse the already loaded value. Refs #18343.</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_parent_chain</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">instance</span><span class="o">.</span><span class="n">refresh_from_db</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">])</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">field_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_check_parent_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the field value can be fetched from a parent field already</span>
<span class="sd">        loaded in the instance. This can be done if the to-be fetched</span>
<span class="sd">        field is a primary key field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">_meta</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">link_field</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_ancestor_link</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">primary_key</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">link_field</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">link_field</span><span class="o">.</span><span class="n">attname</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>


<p>The <code>DeferredAttribute</code> class does not define a <code>__set__</code> method as descriptors 
in other articles.  In such a case, the <code>b.name</code> in a statement <code>b.name = 'Python Tricks</code> 
refers to instance attribute, which overrides the <code>Book.name</code> class level attribute. 
The second answer in 
<a href="https://stackoverflow.com/questions/48537906/how-do-keyword-arguments-interact-with-model-django?rq=1">this stack overflow post</a> 
discusses this particular issue.  It takes me sometime to understand how it&nbsp;works. </p>

    </div>
  </div>

</div>
  
   

    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

  </body>
</html>